---
title: 正则表达式
categories: JavaScript
date: 2022-04-02 17:02:06
tags:
  - JavaScript
---

## 数字相关的正则表达式
```
去空格： /^\s+|\s+$/g
数字： ^[0-9]*$
n位定长的数字： ^\d{n}$
m-n位之间的数字： ^\d{m,n}$
零和非零开头的数字： ^(0|[1-9][0-9]*)$
非零开头的最多带两位小数的数字： ^([1-9][0-9]*)+(.[0-9]{1,2})?$
带1-2位小数的正数或负数： ^(\-)?\d+(\.\d{1,2})?$
正数、负数、和小数： ^(\-|\+)?\d+(\.\d+)?$
有两位小数的正实数： ^[0-9]+(.[0-9]{2})?$
有1~3位小数的正实数： ^[0-9]+(.[0-9]{1,3})?$
正整数： ^\d+$ 或 ^[1-9]\d*|0$
负整数： ^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
正浮点数： 
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 
^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
负浮点数： 
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$
 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
浮点数： ^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
```
## 字符相关的正则表达式
```
汉字： ^[\u4e00-\u9fa5]{0,}$
长度为3-20的所有字符： ^.{3,20}$
由数字和26个英文字母组成的字符串： ^[A-Za-z0-9]+$
由数字、26个英文字母或者下划线组成的字符串： ^\w+$ 或 ^\w{3,20}$
中文、英文、数字包括下划线： ^[\u4E00-\u9FA5A-Za-z0-9_]+$
中文、英文、数字但不包括下划线等符号： 
^[\u4E00-\u9FA5A-Za-z0-9]+$ 
 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)： 
^[a-zA-Z][a-zA-Z0-9_]{4,15}$
密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)： 
^[a-zA-Z]\w{5,17}$
强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：
 ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
```
## 固定格式约定俗成的正则表达式
```
Email地址： ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
网站域名： [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
URL网址： ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
手机号码： 
^(13[0-9]|17[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$

电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、
”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)： 
^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
国内电话号码(0511-4405222、021-87888822)： \d{3}-\d{8}|\d{4}-\d{7}
身份证号(15位、18位数字)： ^\d{15}|\d{18}$
日期格式： ^\d{4}-\d{1,2}-\d{1,2}
一年的12个月(01～09和1～12)： ^(0?[1-9]|1[0-2])$
一个月的31天(01～09和1～31)： ^((0?[1-9])|((1|2)[0-9])|30|31)$
腾讯QQ号： [1-9][0-9]{4,8} (腾讯QQ号从10000开始，目前最长为10位)
中国邮政编码： [1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
IP地址： \d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
IP地址： ((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```
## 常用的方法
### 1.test() 
#### 在字符串中查找符合正则的内容，若查找到返回true,反之返回false.
```
var str = '374829348791';
var re = /\D/; //  \D代表非数字
if (re.test(str)) { // 返回true,代表在字符串中找到了非数字。
    alert('不全是数字');
} else {
    alert('全是数字');
}
```
### 2.search() 
####  在字符串搜索符合正则的内容，搜索到就返回出现的位置
#### （从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回 -1
```
var str = "abc"
var string = 'abbbbccbebababccbaabcbccbaabbccabcc'

function regex(str1, str2) {
    let regex = new RegExp(str1, "g");
    console.log(str2.search(regex));
}
regex(str, string)
```
### 3.match() 
#### 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。
```
var str = 'haj123sdk54hask33dkhalsd879';
var re = /\d+/g; // 每次匹配至少一个数字  且全局匹配  如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，879并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。
alert(str.match(re)); // [123，54，33，879]
```
### replace() 
#### 查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。 
```
var str = "我爱北京天安门，天安门上太阳升。";
var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配
var str2 = str.replace(re,'*'); 
alert(str2)  //我爱**，*上太阳升 

//这种只是把找到的变成了一个*，并不能几个字就对应几个*。
var str = "我爱北京天安门，天安门上太阳升。";
var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配
var str2 = str.replace(re,function(str){
              alert(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门
            var result = '';
            for(var i=0;i<str.length;i++){
                result += '*';
            }              
            return result; //所以搜索到了几个字就返回几个* 
        });
alert(str2)  //我爱*****，***上太阳升         

//整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。
```
把2013-6-7替换成2013.6.7
```
//整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7
var str = '2013-6-7';
var re = /(\d+)(-)/g;

str = str.replace(re,function($0,$1,$2){

      //replace()中如果有子项，
      //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,
      // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d   2013, 6)
      //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )   
    return $1 + '.';  //分别返回2013.   6.

});

alert( str );   //2013.6.7
```

找重复项最多的字符个数
```
// split():字符串中的方法，把字符串转成数组。
// sort():数组中的排序方法，按照ACALL码进行排序。
// join():数组中的方法，把数组转换为字符串

var str = 'assssjdssskssalsssdkjsssdss';
var arr = str.split(''); //把字符串转换为数组
str = arr.sort().join(''); //首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串
//alert(str);  // aaddjjkklsssssssssssssssss

var value = '';
var index = 0;
var re = /(\w)\1+/g;  //匹配字符，且重复这个字符，重复次数至少一次。
str.replace(re,function($0,$1){
  //alert($0);   代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss
  //alert($1);  代表每次匹配成功的第一个子项，也就是\w:  a d j k l S
  if(index<$0.length){  //如果index保存的值小于$0的长度就进行下面的操作
    index = $0.length;  // 这样index一直保存的就在最大的长度
    value = $1;  //value保存的是出现最多的这个字符
  }
});
console.log('最多的字符:'+value+',重复的次数:'+index);  // s   17
```

查找字符串'abc'在字符串'abbbbccbebababccbaabcbccbaabbccabcc'第一次出现的位置
```
var str = "abc"
var string = 'abbbbccbebababccbaabcbccbaabbccabcc'
function regex(str1,str2){
    let regex = new RegExp(str1,"g");
    console.log(str2.search(regex));
}
regex(str,string)
```

